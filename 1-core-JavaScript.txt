==================================== PART 1: CORE JAVASCRIPT ==================================== 

- Character Set: ECMAScript 5 requires implementations to support Unicode 3 or later.

- Case Sensitivity: JavaScript is a case-sensitive language. This means that language keywords, variables, function names, and other identifiers must always be typed with a consistent capitali- zation of letters. The while keyword, for example, must be typed “while,” not “While” or “WHILE.” Similarly, online, Online, OnLine, and ONLINE are four distinct variable names.

- Identifiers and Reserved Words: An identifier is simply a name. A JavaScript iden- tifier must begin with a letter, an underscore (_), or a dollar sign ($). Digits are not allowed as the first character so that JavaScript can easily distinguish identifiers from numbers. For portability and ease of editing, it is common to use only ASCII letters and digits in identifiers. Note, however, that JavaScript allows identifiers to contain letters and digits from the entire Unicode character set. Technically, the ECMAScript standard also allows Unicode characters from the obscure categories Mn, Mc, and Pc to appear in identifiers after the first character.

var sí = true; //valid :)
var π = 3.14; //valid :)
var $ = "hello"; //valid :)
var üşğçö="started with turkis letters.";  //totally valid :) Remember: JavaScript allows identifiers to contain letters and digits from the entire Unicode character set

- Reserved Words: JavaScript reserves a number of identifiers as the keywords of the language itself. You cannot use these words as identifiers in your programs

      break		      delete	    function	    return		 typeof
      case		      do		    if 		    switch		 var
      catch		      else		    in		    this		 void
      continue	      false		    instanceof	    throw		 while
      debugger	      finally	    new		    true		 with
      default		for 		    null		    try		
      
      ECMAScript 5 reserves the following words:      
      class         const         enum            export      extends     import    super
      
      In addition, the following words, which are legal in ordinary JavaScript code, are re- served in strict mode:
      
      implements    let           private         public      yield     interface     package     protected     static

      Strict mode also imposes restrictions on the use of the following identifiers. They are not fully reserved, 
      but they are not allowed as variable, function, or parameter names:
    
      arguments   eval
                      
      
      JavaScript predefines a number of global variables and functions, and you should avoid using their names
      for your own variables and functions:

      arguments           encodeURI             Infinity              Number              RegExp
      Array               encodeURIComponent    isFinite              Object              String
      Boolean             Error                 isNaN                 parseFloat          SyntaxError
      Date                eval                  JSON                  parseInt            TypeError
      decodeURI           EvalError             Math                  RangeError          undefined
      decodeURIComponent  Function              NaN                   ReferenceError      URIError
      
      
- Optional Semicolons: Like many programming languages, JavaScript uses the semicolon (;) to separate state- ment from each other. In JavaScript, you can usually omit the semicolon between two statements if those statements are written on separate lines. Many JavaScript programmers (and the code in this book) use semico- lons to explicitly mark the ends of statements, even where they are not required.

var a = 3  //valid
var b = 4  //valid

a = 3; b = 4; //valid
      
var a           //line 1
a               //line 2
=               //line 3
3               //line 4
console.log(a)  //line 5 :  this 5 lines equal to   var a; a=3; console.log(a);


These statement termination rules lead to some surprising cases. This code looks like two separate statements separated with a newline:
var y = x + f    //line 1
(a+b).toString() //line 2:  this statement evalute like:  var y = x + f(a+b).toString()  :::  this is not the interpretation intended by the author of the code.

There are two exceptions to the general rule that JavaScript interprets line breaks as semicolons when it cannot parse the second line as a continuation of the statement on the first line. The first exception involves the return, break, and continue statements.

return //line 1
true;  //line 2
//above lines: JavaScript assumes you meant: "return; true;"   However, you probably meant: "return true;"


- Types, Variables, Values:
      Number
      String
      Boolean
      Symbol (new in edition 6)
      Object
            Function
            Array
            Date
            RegExp
      null
      undefined

- Numbers: Unlike many languages, JavaScript does not make a distinction between integer values and floating-point values. All numbers in JavaScript are represented as floating-point values. JavaScript represents numbers using the 64-bit floating-point format defined by the IEEE 754 standard,1 which means it can represent numbers as large as ±1.7976931348623157 × 10308 and as small as ±5 × 10−324.

- Integer Literals: 
  base-10 : //1234
  base-16 : // 0xff
  base-8  : // 0377   // 3*64 + 7*8 + 7 = 255 (base 10) :::  you should never write an integer literal with a leading zero; you cannot know in this case whether an implementation will interpret it as an octal or decimal value. In the strict mode of ECMAScript 5 (§5.7.3), octal literals are explicitly forbidden.

- Floating-Point Literals: [digits][.digits][(E|e)[(+|-)]digits]
      3.14
      2345.789
      .333333333333333333
      6.02e5 // 6.02 x 100000 =>602000
      1.4733E-3 // 1.4738223 x (1/1000) =>   0,0014733
      
      
- Arithmetic in JavaScript:      
      Math.pow(2,53)          // => 9007199254740992: 2 to the power 53
	Math.round(.6)          // => 1.0: round to the nearest integer
	Math.ceil(.6)           // => 1.0: round up to an integer
	Math.floor(.6)          // => 0.0: round down to an integer      
	Math.abs(-5)            // => 5: absolute value
	Math.max(x,y,z)         // Return the largest argument
	Math.min(x,y,z)         // Return the smallest argument
	Math.random()           // Pseudo-random number x where 0 <= x < 1.0
	Math.PI                 // π: circumference of a circle / diameter
	Math.E                  // e: The base of the natural logarithm
	Math.sqrt(3)            // the square root of 3
	Math.pow(3, 1/3)        // The cube root of 3
	Math.sin(0)             // Trigonometry: also Math.cos, Math.atan, etc.
	Math.log(10)            // Natural logarithm of 10
	Math.log(100)/Math.LN10 // Base 10 logarithm of 100
	Math.log(512)/Math.LN2  // Base 2 logarithm of 512
	Math.exp(3)             // Math.E cubed
      
	Arithmetic in JavaScript does not raise errors in cases of overflow, underflow, or divi- sion by zero. When the result of a numeric operation is larger than the largest repre- sentable number (overflow), the result is a special infinity value, which JavaScript prints as Infinity. Similarly, when a negative value becomes larger than the largest repre- sentable negative number, the result is negative infinity, printed as -Infinity.
	
	1/0 			// => Infinity
       -1/0			// => -Infinity
        0/0			// => NaN   Not a Number
	Math.sqrt(-number)	// => NaN 
	Infinity/Infinity	// => NaN
	
The not-a-number value has one unusual feature in JavaScript: it does not compare equal to any other value, including itself. This means that you can’t write x == NaN to determine whether the value of a variable x is NaN. Instead, you should write x != x.

	NaN == NaN		// => false :) yes truely, false :)
	isNaN()			// if the parameter, argument is NaN, or a non-numeric value such as a string or an object.

Look at below 3 lines for NaN:
	var x = 0/0;		// => x=NaN
	var y = x != x;		// => y=true beacause it is a way to understand if a variable is NaN. or use isNAN()
	var z = isNaN(x)	// => z = true
	
	isFinite(value); 	//The isFinite() function determines whether a number is a finite, legal number.
	isFinite(123);		// => true
	isFinite("123");	// => true	
	isFinite("123a");	// => false
	isFinite("0x123a");	// => true :)  because  hexadecimal represantation
	isFinite("0x123aH");	// => false :)  it seams like hexadecimal but no "H"! :)
	isFinite("123    ");	// => true :)  white spaces, even cariage returns ommited if there is noanyletter at the end
	
	
	

- Binary Floating-Point and Rounding Errors:

	Because of rounding error, the difference between the approximations of .3 and .2 is not exactly the same 
	as the difference between the approximations of .2 and .1. It is important to understand that this problem 
	is not specific to JavaScript: it affects any programming language that uses binary floating-point numbers. 
	Also, note that the values x and y in the code above are very close to each other and to the correct value. 
	The computed values are adequate for almost any purpose: the problem arises when we attempt to compare 
	values for equality.

	var x= 0.3 - 0.2;		// => 0.09999999999999998
	var y= 0.2 - 0.1;		// => 0.1

	console.log(x == y);		// => false
	console.log(x == 0.1);		// => false
	console.log( x== 0.1);		// => false

	


  






      
      
    
